<!DOCTYPE html>
<html>
<head>
    <style type="text/css">
        html, body {
            margin: 0;
            padding: 0;
        }
    </style>
</head>
<body>
<div id="viewport"></div>
<script type="text/javascript" src="/example/lib/three.js"></script>
<script type="text/javascript" src="/example/lib/ColladaLoader.js"></script>
<script type="text/javascript" src="/example/lib/FirstPersonControl.js"></script>
<script type="text/javascript">
    var scene;
    var camera;
    var camControls;
    var renderer;
    var plane;
    var terrain;
    var loader = new THREE.ColladaLoader();
    var clock = new THREE.Clock();

    window.onload = function() {
        initScene();
    };

    var initScene = function() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(15, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 30, 60);
        camera.lookAt(scene.position);
        var axes = new THREE.AxisHelper(20);
        scene.add(axes);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document
                .getElementById('viewport')
                .appendChild(renderer.domElement);

        initControls();
        createPlane();
        createLight();
        regsterEventListener();
        render();
    };

    var initControls = function() {
        camControls = new THREE.FirstPersonControls(camera);
        camControls.lookSpeed = 0.4;
        camControls.movementSpeed = 20;
        camControls.noFly = true;
        camControls.lookVertical = true;
        camControls.constrainVertical = true;
        camControls.verticalMin = 1.0;
        camControls.verticalMax = 2.0;
        camControls.lon = -150;
        camControls.lat = 120;
    };

    var render = function() {
        var delta = clock.getDelta();

        plane.updateMatrixWorld(true);
        plane.updateMatrix();
        plane.geometry.computeTangents();
        plane.geometry.dynamic = true;
        plane.geometry.normalsNeedUpdate = true;
        plane.geometry.tangentsNeedUpdate = true;
        plane.geometry.tangentsNeedUpdate = true;
        plane.geometry.needsUpdate = true;
        var position = new THREE.Vector3();
        position.getPositionFromMatrix( plane.matrixWorld );
        console.log('pos2: ', position.x + ',' + position.y + ',' + position.z);
        //camControls.update(delta);

        setTimeout(function() {
            requestAnimationFrame(render);
        }, 1500);
        renderer.render(scene, camera);
    };

    var createPlane = function() {
        var shaderMaterial = new THREE.ShaderMaterial({
            vertexShader:   document.getElementById('vertexshader').innerText,
            fragmentShader: document.getElementById('fragmentshader').innerText,
            wireframe: true
        });

        var planeGeometry = new THREE.PlaneGeometry(5, 5, 4, 4);
        planeGeometry.computeBoundingSphere();
        var planeMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            wireframe: true
        });

        plane = new THREE.Mesh(planeGeometry, shaderMaterial);
        plane.position.set(0, -1, 0);
        plane.rotation.x = -0.5 * Math.PI;
        plane.dynamic = true;
        plane.geometry.computeVertexNormals();
        plane.geometry.computeFaceNormals();
        plane.geometry.__dirtyVertices = true;
        plane.geometry.__directGeometry = true;
        plane.geometry.__dirtyPosition = true;
        plane.geometry.__dirtyNormals = true;
        scene.add(plane);
    };

    var createLight = function() {
        var ambientLight = new THREE.AmbientLight(0xE0E0E0);
        scene.add(ambientLight);

        var spotlight = new THREE.SpotLight(0xFFFFFF);
        spotlight.position.set(50, 60, 0);
        spotlight.lookAt(plane);

        var spotlightHelper = new THREE.SpotLightHelper(spotlight);

        scene.add(spotlightHelper);
    };


    var regsterEventListener = function() {
        var raycaster = new THREE.Raycaster();
        window.addEventListener( 'click', function(event) {
            var mouse = {};
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

            // calculate mouse position in normalized device coordinates
            // (-1 to +1) for both components
            raycaster.setFromCamera( mouse, camera );

            // See if the ray from the camera into the world hits one of our meshes

            var intersects = raycaster.intersectObject( plane, true );
            // Toggle rotation bool for meshes that we clicked
            var match = intersects[0];
            console.log(match);
            console.log(match.faceIndex);
            if (match) {
                var geometry = match.object.geometry;
                var material = match.object.material;
                var face = geometry.faces[match.faceIndex];
                var vertices = geometry.vertices;
                var v1 = vertices[ face.a ];
                var v2 = vertices[ face.b ];
                var v3 = vertices[ face.c ];

                var position = new THREE.Vector3();
                position.x = ( v1.x + v2.x + v3.x ) / 3;
                position.y = ( v1.y + v2.y + v3.y ) / 3;
                position.z = ( v1.z + v2.z + v3.z ) / 3;

                console.log(position);
            }
        });
    };

</script>
<script type="x-shader/x-vertex" id="vertexshader">
        
        // switch on high precision floats
        #ifdef GL_ES
        precision highp float;
        #endif
        
        void main()
        {
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,0.5);
        }
        
    </script>

<script type="x-shader/x-fragment" id="fragmentshader">
    
        #ifdef GL_ES
        precision highp float;
        #endif
        
        void main()
        {
            gl_FragColor = vec4(1.0,0.0,1.0,1.0);
        }
    
    </script>

</body>
</html>